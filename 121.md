# NIP-121

## Basic Joins
`draft` `optional` `author:j19710815`

### Introduction

This NIP introduces the `join` filter property as a pragmatic solution for common querying patterns performed by clients. The goal of this proposal is to improve UX for users of Nostr clients and the DX for client developers. This NIP enables clients to easily retrieve related, cross referenced notes. It does not seek to solve all querying challenges faced by clients interacting with the Nostr protocol. Rather it seeks to solve the most common use cases with the least amount of surface area in terms of protocol enhancement.

### Motivation

There is presently no way to perform a join among events when retrieving related data as one might do when querying a relational or nosql database. For instance, nearly every client displays a list of users with their profile image and display name. Currently, in order for a client to achieve this (without going out of band), the client must first retrieve a list of pubkeys (e.g., a user’s Kind 3 follows list), then open another filter for Kind 0 profile data that includes that list of users as authors, then filter the response to disregard any irrelevant (stale) data, match it to its use in the interface, then pass it along to a display function. Alternatively, the client could query relays for Kind 0 profile data for each user individually. 

Should the initial list of users change, the process is run again on the client with the updated filters passed along to relays, or otherwise, complex caching is required to optimize for efficiency. The inability to retrieve related data with a single filter leads to an unrefined experience for users and an unnecessarily complex code base for clients. While this can all be optimized for by the client, it requires an inordinate amount of development time and computation put toward a technical concern that has long been solved by query languages.

### Solution

The solution is presented in two parts: 1) through the introduction of a `join` property when filtering allowing the client to specify which tags ("p", "e", or "a") should include cross referenced events in the response, and 2) the introduction of a third index in the “p”, “e”, and “a” tag arrays on event responses. So that for each “p” tag, the associated Kind 0 event would be returned (if one exists), and for each “e” and “a” tag, the referenced event would be returned regardless of Kind. The third index for each of these tags contains a stringified version of the referenced event.

#### Example Contacts Query:
```json
{
   "authors": [“alice”],
   "kinds": [3],
   "join": ["p”]
}
```

#### Example Contacts Response:
```json
{
   "pubkey": "alice",
   "kind": 3,
   "tags": [
      ["p": "bob", <recommended relay URL>, <stringified Kind 0 event posted by bob>],
      ["p": "june", <recommended relay URL>, <stringified Kind 0 event posted by june>],
      ["p": "tim", <recommended relay URL>, <stringified Kind 0 event posted by tim>],
      ["p": "jane", <recommended relay URL>, <stringified Kind 0 event posted by jane>]
   ]
   ...
}
```

#### Example Note Query:

```json
{
   "authors": ["alice"],
   "kinds": [1],
   "join": ["p”, "e", "a"]
}
```

#### Example Note Response:
```json
{
   "pubkey": "alice",
   "kind": 1,
   "tags": [
      ["p": bob, <recommended relay URL>, <stringified Kind 0 event posted by bob>],
      ["e": <note id hex>, <recommended relay URL>, <stringified event matching the specified event id>]
      ["a": <kind>:<pubkey>:<d-identifier>, <recommended relay URL>, <stringified event matching the specified naddr code>]
   ]
   ...
}
```

### Live Updates

Regarding live updates, a new event is only broadcast by the relay when the requested primary event or events are modified, not the included cross referenced events. As a result, this method would only be used when it is not critical for the client to display the most up to date data for cross referenced events (as is often the case).

### Scope

It might be tempting to expand on this simple joining mechanism, perhaps by providing a means to retrieve a user’s contact list or most recent note(s). The goal however, is to solve for the most common cases with the smallest footprint possible while leaving the door open to the introduction of a much more robust querying mechanism in the future.

